#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2023-2025 NXP
#
# SPDX-License-Identifier: BSD-3-Clause
"""NXPDICE application is designed to cover DICE-related operations."""

import logging
import os
import secrets
import sys
import textwrap
from typing import Optional

import click
import colorama
import prettytable
from click_option_group import RequiredMutuallyExclusiveOptionGroup, optgroup

from spsdk.apps.utils.common_cli_options import (
    FC,
    CommandsTreeGroup,
    port_option,
    spsdk_apps_common_options,
    spsdk_family_option,
    timeout_option,
)
from spsdk.apps.utils.utils import SPSDKAppError, catch_spsdk_error
from spsdk.crypto.keys import EccCurve, PrivateKeyEcc
from spsdk.dice.models import APIResponse, DICEResponse
from spsdk.dice.service_local import LocalDICEVerificationService
from spsdk.dice.service_remote import DICEVerificationService, RemoteDICEVerificationService
from spsdk.dice.target_blhost import BlhostDICETarget, DICETarget
from spsdk.dice.target_model import ModelDICETarget
from spsdk.dice.utils import HADDiff, HADDifferences, get_supported_devices
from spsdk.mboot.interfaces.uart import MbootUARTInterface
from spsdk.mboot.protocol.base import MbootProtocolBase
from spsdk.utils.family import FamilyRevision
from spsdk.utils.misc import write_file
from spsdk.utils.registers import Register, RegsBitField

logger = logging.getLogger(__name__)


def service_options(options: FC) -> FC:
    """Verification service selection options.

    Provides: service_url: str, database: str
    """
    options = optgroup.option(
        "-db",
        "--database",
        type=click.Path(dir_okay=False),
        help="Path to local database instead of service-url.",
    )(options)
    options = optgroup.option(
        "-su",
        "--service-url",
        type=str,
        help="DICE verification service URL. Example: http://localhost:8080",
    )(options)
    # The group is created at the end, because the options are backwards
    options = optgroup(
        "Verification service selection",
        cls=RequiredMutuallyExclusiveOptionGroup,
    )(options)

    return options


def models_options(options: FC) -> FC:
    """Provides path to MCU model files: models_dir: str."""
    options = click.option(
        "-md",
        "--models-dir",
        required=False,
        type=click.Path(file_okay=False, exists=True),
        help=(
            "Path to folder with MCU model files. "
            "When using models the `--port` option is used as sub-folder name in `models-dir`"
        ),
    )(options)
    return options


def store_artifact_options(options: FC) -> FC:
    """Provides a path where to store artifacts: store-artifact: str."""
    options = click.option(
        "-s",
        "--store-artifact",
        required=False,
        type=click.Path(dir_okay=False),
        help="Path where to store artifact (data) generated by the command.",
    )(options)
    return options


def get_verification_service(
    service_url: Optional[str] = None, database: Optional[str] = None
) -> DICEVerificationService:
    """Factory method for retrieving concrete verification service instance."""
    if service_url and database:
        raise SPSDKAppError("Only one of 'service_url' and 'database must be specified!")
    if service_url:
        return RemoteDICEVerificationService(base_url=service_url)
    if database:
        return LocalDICEVerificationService(file_path=database)
    raise SPSDKAppError("One of 'service_url' and 'database must be specified!")


def get_dice_target(
    port: str,
    timeout: int = 5000,
    family: Optional[FamilyRevision] = None,
    models_dir: Optional[str] = None,
) -> DICETarget:
    """Factory method for retrieving concrete DICE target instance."""
    if port is None:
        raise SPSDKAppError("-p/--port needs to be set.")
    if models_dir:
        return ModelDICETarget(models_dir=models_dir, port=port.split(",")[0])
    assert isinstance(family, FamilyRevision)
    interfaces = MbootUARTInterface.scan(port=port, timeout=timeout)
    if len(interfaces) == 0:
        raise SPSDKAppError(f"Could not found device on '{port}'")
    assert isinstance(interfaces[0], MbootProtocolBase)
    return BlhostDICETarget(family=family, interface=interfaces[0])


@click.group(name="nxpdice", cls=CommandsTreeGroup)
@spsdk_apps_common_options
def main(log_level: int) -> int:
    """Application designed to cover DICE-related operations."""
    logging.basicConfig(level=log_level or logging.WARNING)
    return 0


@main.command(name="register-ca-puk", no_args_is_help=True)
@service_options
@port_option()
@timeout_option()
@spsdk_family_option(families=get_supported_devices())
@models_options
@click.option(
    "--rkth",
    type=str,
    required=True,
    help="HEX value of RKTH",
)
@store_artifact_options
def register_ca_puk(
    service_url: str,
    database: str,
    port: str,
    timeout: int,
    family: FamilyRevision,
    store_artifact: str,
    models_dir: str,
    rkth: str,
) -> None:
    """Get NXP_CUST_DICE_CA_PUK from the device and register it in the verification service."""
    rkth_bytes = bytes.fromhex(rkth)
    if len(rkth_bytes) != 32:
        raise SPSDKAppError(f"RKTH must be 32B long. Got {len(rkth_bytes)}")
    target = get_dice_target(port=port, timeout=timeout, family=family, models_dir=models_dir)
    service = get_verification_service(service_url=service_url, database=database)

    puk_data = target.get_ca_puk(rkth=rkth_bytes)
    click.echo(f"Registering NXP_CUST_DICE_CA_PUK: {puk_data.hex()}")
    if store_artifact:
        write_file(data=puk_data, path=store_artifact, mode="wb")

    response = service.register_dice_ca_puk(key_data=puk_data)
    display_response(response=response)


@main.command(name="get-ca-puk", no_args_is_help=True)
@port_option()
@timeout_option()
@spsdk_family_option(families=get_supported_devices())
@models_options
@click.option(
    "-o",
    "--output",
    type=click.Path(dir_okay=False),
    required=True,
    help="Path where to store the NXP_CUST_DICE_CA_PUK",
)
@click.option(
    "--rkth",
    type=str,
    required=True,
    help="HEX value of RKTH",
)
def get_ca_puk(
    port: str, timeout: int, family: FamilyRevision, models_dir: str, output: str, rkth: str
) -> None:
    """Get NXP_CUST_DICE_CA_PUK from the device."""
    rkth_bytes = bytes.fromhex(rkth)
    if len(rkth_bytes) != 32:
        raise SPSDKAppError(f"RKTH must be 32B long. Got {len(rkth_bytes)}")
    target = get_dice_target(port=port, timeout=timeout, family=family, models_dir=models_dir)

    puk_data = target.get_ca_puk(rkth=rkth_bytes)
    write_file(data=puk_data, path=output, mode="wb")


@main.command(name="upload-ca-puk", no_args_is_help=True)
@service_options
@click.option(
    "-c",
    "--ca-puk",
    type=click.Path(exists=True, dir_okay=False),
    required=True,
    help="Path to binary file containing NXP_CUST_DICE_CA_PUK key.",
)
def upload_ca_puk(service_url: str, database: str, ca_puk: str) -> None:
    """Upload existing NXP_CUST_DICE_CA_PUK into the verification service."""
    with open(ca_puk, "rb") as f:
        puk_data = f.read()
    if len(puk_data) != 64:
        raise SPSDKAppError(f"NXP_CUST_DICE_CA_PUK should be 64B long. Got: {len(puk_data)}")

    service = get_verification_service(service_url=service_url, database=database)
    click.echo(f"Registering NXP_CUST_DICE_CA_PUK: {puk_data.hex()}")
    response = service.register_dice_ca_puk(key_data=puk_data)
    display_response(response=response)


@main.command(name="register-version", no_args_is_help=True)
@service_options
@port_option()
@timeout_option()
@spsdk_family_option(families=get_supported_devices())
@models_options
@store_artifact_options
def register_version(
    service_url: str,
    database: str,
    port: str,
    timeout: int,
    family: FamilyRevision,
    store_artifact: str,
    models_dir: str,
) -> None:
    """Register new FW version, RTF, and HAD based on DICE response."""
    target = get_dice_target(port=port, timeout=timeout, family=family, models_dir=models_dir)
    service = get_verification_service(service_url=service_url, database=database)

    response_data = target.get_dice_response(challenge=secrets.token_bytes(32))
    if store_artifact:
        write_file(data=response_data, path=store_artifact, mode="wb")

    response = service.register_version(data=response_data)
    display_response(response=response)


@main.command(name="upload-version", no_args_is_help=True)
@service_options
@click.option(
    "-r",
    "--response",
    "response_file",
    type=click.Path(exists=True, dir_okay=False),
    help="Path to DICE response binary. Info in response will be used to register new version.",
)
def upload_version(service_url: str, database: str, response_file: str) -> None:
    """Upload existing DICE response to register new FW version, RTF, and HAD."""
    with open(response_file, "rb") as f:
        response_data = f.read()
    if len(response_data) != 324:
        raise SPSDKAppError(f"DICE response should be 324B long. Got: {len(response_data)}")

    service = get_verification_service(service_url=service_url, database=database)
    response = service.register_version(data=response_data)
    display_response(response=response)


@main.command(name="verify", no_args_is_help=True)
@service_options
@port_option()
@timeout_option()
@spsdk_family_option(families=get_supported_devices())
@models_options
@store_artifact_options
def verify(
    service_url: str,
    database: str,
    port: str,
    timeout: int,
    family: FamilyRevision,
    store_artifact: str,
    models_dir: str,
) -> None:
    """Perform the DICE attestation verification."""
    target = get_dice_target(port=port, timeout=timeout, family=family, models_dir=models_dir)
    service = get_verification_service(service_url=service_url, database=database)

    challenge = service.get_challenge()
    logger.info(f"Challenge: {challenge.hex()}")
    dice_response = target.get_dice_response(challenge=challenge)
    click.echo(f"Submitting DICE Response:\n{DICEResponse.parse(data=dice_response).info()}")
    if store_artifact:
        write_file(data=dice_response, path=store_artifact, mode="wb")

    response = service.verify(data=dice_response)
    display_had_diff(response=response, family=family)
    display_response(response=response)


@main.command(name="get-response", no_args_is_help=True)
@port_option()
@timeout_option()
@spsdk_family_option(families=get_supported_devices())
@models_options
@click.option(
    "--response",
    type=click.Path(dir_okay=False),
    required=True,
    help="Path where to store the DICE response",
)
@click.option(
    "-c",
    "--challenge",
    help="Optional challenge. If not specified a random challenge will be used.",
)
def get_response(
    port: str, timeout: int, family: FamilyRevision, models_dir: str, response: str, challenge: str
) -> None:
    """Get DICE response from the device."""
    if challenge:
        challenge_data = bytes.fromhex(challenge)
    else:
        challenge_data = secrets.token_bytes(32)
    if len(challenge_data) != 32:
        raise SPSDKAppError(f"Challenge must be 32B. Got: {len(challenge_data)}")

    target = get_dice_target(port=port, timeout=timeout, family=family, models_dir=models_dir)
    response_data = target.get_dice_response(challenge=challenge_data)
    write_file(data=response_data, path=response, mode="wb")


@main.command(name="upload-response", no_args_is_help=True)
@service_options
@click.option(
    "-r",
    "--response",
    "response_file",
    type=click.Path(exists=True, dir_okay=False),
    required=True,
    help="Path to binary file containing the DICE response.",
)
def upload_response(service_url: str, database: str, response_file: str) -> None:
    """Upload existing DICE response for verification."""
    with open(response_file, "rb") as f:
        dice_response = f.read()
    if len(dice_response) != 324:
        raise SPSDKAppError(f"DICE response should be 324 B long. Got: {len(dice_response)}")
    click.echo(f"Submitting DICE Response:\n{DICEResponse.parse(data=dice_response).info()}")

    service = get_verification_service(service_url=service_url, database=database)
    response = service.verify(data=dice_response, reset_challenge=True)
    display_response(response=response)


@main.command(name="create-models", no_args_is_help=True)
@click.option(
    "-md",
    "--models-dir",
    type=click.Path(file_okay=False, exists=False),
    help="Path to directory where to create models directory for debugging purposes",
)
@click.option(
    "-n",
    "--number",
    type=click.IntRange(min=1),
    required=True,
    help="Number of virtual devices to crate for debugging purposes.",
)
@click.option(
    "-p",
    "--prefix",
    type=str,
    default="com9",
    help="Prefix for device model names. Number of device will be appended to the prefix.",
)
def create_models(models_dir: str, number: int, prefix: str) -> None:
    """Create models directory for debugging purposes."""
    click.echo(f"Creating root models folder: {models_dir}")
    os.makedirs(models_dir)
    dice_ca_prk = PrivateKeyEcc.generate_key(EccCurve.SECP256R1)
    dice_ca_prk.save(file_path=os.path.join(models_dir, "dice_ca_prk.pem"))

    dice_ca_puk = dice_ca_prk.get_public_key()
    dice_ca_puk.save(file_path=os.path.join(models_dir, "dice_ca_puk.pem"))

    rtf = secrets.token_hex(32)
    # default (after-reset) HAD value
    had = "0ff0035500000022ffffffff000000000000dc000000018f000000000000000000000000000000000000000000000000"
    with open(os.path.join(models_dir, "config.yaml"), "w", encoding="utf-8") as f:
        f.writelines(
            [
                "dice_ca_prk: dice_ca_prk.pem\n",
                "dice_ca_puk: dice_ca_puk.pem\n",
                f"rtf: {rtf}\n",
                f"had: {had}\n",
                "version: 1\n",
            ]
        )
    click.echo("Root model directory created")
    for i in range(number):
        click.get_current_context().invoke(add_device, models_dir=models_dir, name=f"{prefix}{i}")


@main.command(name="add-device", no_args_is_help=True)
@models_options
@click.option("-n", "--name", type=str, required=True, help="Name for the device")
def add_device(models_dir: str, name: str) -> None:
    """Add virtual device to the models_dir."""
    click.echo(f"Creating device model: {name}")
    os.makedirs(os.path.join(models_dir, name))
    die_prk = PrivateKeyEcc.generate_key(EccCurve.SECP256R1)
    die_prk.save(file_path=os.path.join(models_dir, name, "die_prk.pem"))

    die_puk = die_prk.get_public_key()
    die_puk.save(file_path=os.path.join(models_dir, name, "die_puk.pem"))

    uuid = secrets.token_hex(16)
    with open(os.path.join(models_dir, name, "config.yaml"), "w", encoding="utf-8") as f:
        f.writelines(
            [
                f"uuid: {uuid}\n",
                "die_prk: die_prk.pem\n",
                "die_puk: die_puk.pem\n",
                "dice_ca_puk: \n",
                "dice_ca_prk: \n",
                "rtf: \n",
                "had: \n",
                "version: \n",
                "challenge: \n",
            ]
        )


def display_response(response: APIResponse) -> None:
    """Colorized display of a APIResponse."""
    string = colorama.Fore.GREEN if response.success else colorama.Fore.LIGHTRED_EX
    string += response.message + colorama.Fore.RESET
    click.echo(message=string)
    click.get_current_context().exit(0 if response.success else 1)


def display_had_diff(response: APIResponse, family: FamilyRevision) -> None:
    """Display detailed breakdown of HAD differences."""
    if not response.status == "HAD_DIFF":
        return
    if not response.expected_had or not response.actual_had:
        raise SPSDKAppError("HAD data is missing in the response")

    click.echo(colorama.Fore.YELLOW + "HAD difference detected!" + colorama.Fore.RESET)
    click.echo(f"Expected: {response.expected_had}")
    click.echo(f"Actual  : {response.actual_had}")
    had = HADDiff(family=family)
    differences = had.get_diff(response.expected_had, response.actual_had)

    if len(differences) == 0:
        click.echo(
            colorama.Fore.YELLOW
            + "Differences occurred only in RESERVED fields"
            + colorama.Fore.RESET
        )
        return

    display_had_diff_table(differences=differences)

    critical_differences = had.get_diff(
        response.expected_had, response.actual_had, critical_only=True
    )
    if len(critical_differences) == 0:
        return

    click.echo(
        colorama.Fore.LIGHTRED_EX + "Critical HAD differences detected!" + colorama.Fore.RESET
    )
    display_had_diff_table(
        differences=critical_differences, title="Critical HAD differences breakdown"
    )
    click.echo(
        colorama.Fore.LIGHTRED_EX
        + "DICE response verification failed due to critical HAD differences"
        + colorama.Fore.RESET
    )
    click.get_current_context().exit(1)


def display_had_diff_table(
    differences: HADDifferences, title: str = "HAD differences breakdown"
) -> None:
    """Display the HAD differences in a table."""
    table = prettytable.PrettyTable(
        title=title,
        field_names=["register", "bit-field", "expected", "actual", "description"],
        header_style="cap",
        hrules=True,
    )
    table.align["description"] = "l"

    def format_bitfield(b: RegsBitField) -> str:
        if b.width == 1:
            return str(b.get_value())
        form = f"#0{b.width + 2}b"
        return f"{b.get_value():{form}}"

    for d1, d2 in differences:
        if isinstance(d1, Register):
            table.add_row(
                [
                    d1.name,
                    "---",
                    d1.get_hex_value(),
                    d2.get_hex_value(),
                    "\n".join(textwrap.wrap(d1.description, 50)),
                ]
            )
        else:
            # oh dead Mypy, Pyright knows this, why don't you?
            assert isinstance(d1, RegsBitField) and isinstance(d2, RegsBitField)
            table.add_row(
                [
                    d1.parent.name,
                    d1.name,
                    format_bitfield(d1),
                    format_bitfield(d2),
                    "\n".join(textwrap.wrap(d1.description, 50)),
                ]
            )
    click.echo(table.get_formatted_string())


@catch_spsdk_error
def safe_main() -> None:
    """Call the main function."""
    sys.exit(main())  # pylint: disable=no-value-for-parameter


if __name__ == "__main__":
    safe_main()

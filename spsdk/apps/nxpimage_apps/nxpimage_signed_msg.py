#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright 2025 NXP
#
# SPDX-License-Identifier: BSD-3-Clause
"""Nxpimage Signed Message group."""

import logging
import os
from typing import Optional

import click

from spsdk.apps.utils.common_cli_options import (
    CommandsTreeGroup,
    spsdk_config_option,
    spsdk_family_option,
    spsdk_output_option,
)
from spsdk.apps.utils.utils import SPSDKAppError, print_verifier_to_console
from spsdk.exceptions import SPSDKError
from spsdk.image.ahab.ahab_data import FlagsSrkSet
from spsdk.image.ahab.signed_msg import MessageCommands, SignedMessage, SignedMessageContainer
from spsdk.utils.config import Config
from spsdk.utils.family import FamilyRevision
from spsdk.utils.misc import load_binary, load_hex_string, write_file

logger = logging.getLogger(__name__)


@click.group(name="signed-msg", cls=CommandsTreeGroup)
def signed_msg_group() -> None:  # pylint: disable=unused-argument
    """Group of sub-commands related to Signed messages."""


@signed_msg_group.command(name="export", no_args_is_help=True)
@spsdk_config_option(klass=SignedMessage)
def signed_msg_export(config: Config) -> None:
    """Generate Signed message Image from YAML/JSON configuration.

    The configuration template files could be generated by subcommand 'get-template'.
    """
    signed_message = SignedMessage.load_from_config(config=config)
    signed_message.update_fields()
    signed_msg_data = signed_message.export()

    signed_msg_output_file_path = config.get_output_file_name("output")
    write_file(signed_msg_data, signed_msg_output_file_path, mode="wb")

    logger.info(f"Created Signed message Image:\n{str(signed_message.image_info())}")
    logger.info(f"Created Signed message Image memory map:\n{signed_message.image_info().draw()}")
    if not (
        signed_message.signed_msg_container
        and signed_message.signed_msg_container.signature_block
        and signed_message.signed_msg_container.signature_block.srk_assets
    ):
        raise SPSDKAppError("SRK assets not found in the signed message")
    logger.info(
        f"SRK hash:{signed_message.signed_msg_container.signature_block.srk_assets.compute_srk_hash().hex()}"
    )
    click.echo(f"Success. (Signed message: {signed_msg_output_file_path} created.)")


@signed_msg_group.command(name="parse", no_args_is_help=True)
@spsdk_family_option(families=SignedMessage.get_supported_families())
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary Signed message image to parse.",
)
@spsdk_output_option(directory=True)
def signed_msg_parse(family: FamilyRevision, binary: str, output: str) -> None:
    """Parse Signed message Image into YAML configuration and binary images."""
    data = load_binary(binary)
    preparsed = SignedMessage.pre_parse_verify(data)
    if preparsed.has_errors:
        click.echo("The signed message image bases has error, it doesn't passed pre-parse check:")
        click.echo(preparsed.draw())
        raise SPSDKAppError("Pre-parsed check failed")
    if not os.path.exists(output):
        os.makedirs(output, exist_ok=True)
    try:
        signed_message = SignedMessage.parse(data, family=family)
    except SPSDKError as exc:
        click.echo(f"Signed message parsing failed: {binary} ,({str(exc)})")
        return

    logger.info(f"Parsed Signed message image memory map: {signed_message.image_info().draw()}")

    write_file(signed_message.get_config_yaml(output), os.path.join(output, "parsed_config.yaml"))
    click.echo(f"Success. (Signed message: {binary} has been parsed and stored into {output}.)")
    for ix in range(signed_message.srk_count):
        srk_hash = signed_message.get_srk_hash(ix)
        assert isinstance(signed_message.signed_msg_container, SignedMessageContainer)
        file_name = os.path.join(
            output, f"{signed_message.signed_msg_container.flag_srk_set.label}_srk{ix}_hash"
        )
        write_file(srk_hash.hex().upper(), f"{file_name}.txt")
        click.echo(f"Generated SRK hash file ({file_name}.txt)")


@signed_msg_group.command(name="get-template", no_args_is_help=True)
@spsdk_family_option(families=SignedMessage.get_supported_families())
@click.option(
    "-m",
    "--message",
    required=False,
    type=click.Choice(MessageCommands.labels(), case_sensitive=False),
    help="Select only one signed message to generate specific template if needed",
)
@spsdk_output_option(force=True)
def signed_msg_get_template(family: FamilyRevision, message: Optional[str], output: str) -> None:
    """Create template of configuration in YAML format.

    The template file name is specified as argument of this command.
    """
    click.echo(f"Creating {output} template file.")
    write_file(
        SignedMessage.get_config_template(
            family, MessageCommands.from_attr(message) if message else None
        ),
        output,
    )


@signed_msg_group.command(name="verify", no_args_is_help=True)
@spsdk_family_option(families=SignedMessage.get_supported_families())
@click.option(
    "-b",
    "--binary",
    type=click.Path(exists=True, readable=True, resolve_path=True),
    required=True,
    help="Path to binary AHAB image to parse.",
)
@click.option(
    "-p",
    "--problems",
    is_flag=True,
    default=False,
    help="Show just problems in image.",
)
@click.option(
    "-k",
    "--dek",
    type=str,
    required=False,
    help=(
        "Data encryption key, if it's specified, the parse method tries decrypt all encrypted images. "
        "It could be specified as binary/HEX text file path or directly HEX string"
    ),
)
def signed_msg_verify_command(
    family: FamilyRevision, binary: str, dek: str, problems: bool
) -> None:
    """Verify AHAB Image."""
    signed_msg_verify(family=family, binary=binary, dek=dek, problems=problems)


def signed_msg_verify(family: FamilyRevision, binary: str, dek: str, problems: bool) -> None:
    """Verify AHAB Image."""
    data = load_binary(binary)
    preparsed = SignedMessage.pre_parse_verify(data)
    if preparsed.has_errors:
        click.echo("The signed message image bases has error, it doesn't passed pre-parse check:")
        print_verifier_to_console(preparsed)
        raise SPSDKAppError("Pre-parsed check failed")

    signed_msg_image = SignedMessage.parse(data, family=family)
    ver = signed_msg_image.verify()

    if ver.has_errors:
        click.echo("The binary has errors!", err=True)
        print_verifier_to_console(ver)
        raise SPSDKAppError("Verify failed")

    assert isinstance(signed_msg_image.signed_msg_container, SignedMessageContainer)
    if (
        signed_msg_image.signed_msg_container.flag_srk_set != FlagsSrkSet.NXP
        and signed_msg_image.signed_msg_container.signature_block
        and signed_msg_image.signed_msg_container.signature_block.blob
    ):
        signed_msg_image.signed_msg_container.signature_block.blob.dek = (
            load_hex_string(
                dek, signed_msg_image.signed_msg_container.signature_block.blob._size // 8
            )
            if dek
            else None
        )

    if not problems:
        click.echo(signed_msg_image.image_info().draw())

    print_verifier_to_console(signed_msg_image.verify())

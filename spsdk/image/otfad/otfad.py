#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2019-2025 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

"""SPSDK On-The-Fly AES Decryption (OTFAD) support for NXP devices.

This module provides functionality for configuring and managing OTFAD regions
that enable transparent decryption of encrypted flash memory content during
code execution.
"""

import logging
import os
from copy import deepcopy
from dataclasses import dataclass
from struct import pack
from typing import Any, Optional, Union

from typing_extensions import Self

from spsdk.apps.utils.utils import filepath_from_config
from spsdk.crypto.crc import CrcAlg, from_crc_algorithm
from spsdk.crypto.rng import random_bytes
from spsdk.crypto.symmetric import Counter, aes_ctr_encrypt, aes_key_wrap
from spsdk.exceptions import SPSDKError, SPSDKValueError
from spsdk.fuses.fuses import FuseScript
from spsdk.utils.abstract_features import FeatureBaseClass
from spsdk.utils.binary_image import BinaryImage
from spsdk.utils.config import Config
from spsdk.utils.database import DatabaseManager, get_schema_file
from spsdk.utils.family import FamilyRevision, get_db, update_validation_schema_family
from spsdk.utils.misc import (
    Endianness,
    align_block,
    load_binary,
    reverse_bits,
    split_data,
    value_to_bytes,
    value_to_int,
    write_file,
)

logger = logging.getLogger(__name__)


class KeyBlob:
    """OTFAD KeyBlob for AES encryption configuration.

    This class represents a key blob structure that specifies AES key and counter initial value
    for a defined address range in OTFAD (On-The-Fly AES Decryption) operations. It manages
    encryption parameters, address range validation, and provides functionality for image
    encryption and key blob export.

    | typedef struct KeyBlob
    | {
    |     unsigned char key[kAesKeySizeBytes]; // 16 bytes, 128-bits, KEY[A15...A00]
    |     unsigned char ctr[kCtrSizeBytes];    // 8 bytes, 64-bits, CTR[C7...C0]
    |     unsigned int srtaddr;                // region start, SRTADDR[31 - 10]
    |     unsigned int endaddr;                // region end, ENDADDR[31 - 10]; lowest three bits are used as flags
    |     // end of 32-byte area covered by CRC
    |     unsigned int zero_fill;      // zeros
    |     unsigned int key_blob_crc32; // crc32 over 1st 32-bytes
    |     // end of 40 byte (5*64-bit) key blob data
    |     unsigned char expanded_wrap_data[8]; // 8 bytes, used for wrap expanded data
    |     // end of 48 byte (6*64-bit) wrap data
    |     unsigned char unused_filler[16]; // unused fill to 64 bytes
    | } keyblob_t;

    :cvar KEY_FLAG_READ_ONLY: Read-only flag for context registers (0x4).
    :cvar KEY_FLAG_ADE: AES Decryption Enable flag (0x2).
    :cvar KEY_FLAG_VLD: Valid context flag (0x1).
    :cvar KEY_SIZE: AES key length in bytes (16).
    :cvar CTR_SIZE: Counter length in bytes (8).
    """

    _START_ADDR_MASK = 0x400 - 1
    # Region addresses are modulo 1024
    # The address ends with RO, ADE, VLD bits. From this perspective, only
    # bits [9:3] must be set to 1. The rest is configurable.
    _END_ADDR_MASK = 0x3F8

    # Key flags mask: RO, ADE, VLD
    _KEY_FLAG_MASK = 0x07
    # This field signals that the entire set of context registers (CTXn_KEY[0-3], CTXn_CTR[0-1],
    # CTXn_RGD_W[0-1] are read-only and cannot be modified. This field is sticky and remains
    # asserted until the next system reset. SR[RRAM] provides another level of register access
    # control and is independent of the RO indicator.
    KEY_FLAG_READ_ONLY = 0x4
    # AES Decryption Enable: For accesses hitting in a valid context, this bit indicates if the fetched data is to be
    # decrypted or simply bypassed.
    KEY_FLAG_ADE = 0x2
    # Valid: This field signals if the context is valid or not.
    KEY_FLAG_VLD = 0x1

    # key length in bytes
    KEY_SIZE = 16
    # counter length in bytes
    CTR_SIZE = 8
    # len of counter init value for export
    _EXPORT_CTR_IV_SIZE = 8
    # this constant seems to be fixed for SB2.1
    _EXPORT_NBLOCKS_5 = 5
    # binary export size
    _EXPORT_KEY_BLOB_SIZE = 64
    # QSPI image alignment length, 512 is supposed to be the safe alignment level for any QSPI device
    # this means that all QSPI images generated by this tool will be sizes of multiple 512
    _IMAGE_ALIGNMENT = 512
    # Encryption block size
    _ENCRYPTION_BLOCK_SIZE = 16

    def __init__(
        self,
        start_addr: int,
        end_addr: int,
        key: Optional[bytes] = None,
        counter_iv: Optional[bytes] = None,
        key_flags: int = KEY_FLAG_VLD | KEY_FLAG_ADE,
        # for testing
        zero_fill: Optional[bytes] = None,
        crc: Optional[bytes] = None,
    ):
        """Initialize OTFAD key blob with encryption parameters.

        Creates a new OTFAD (On-The-Fly AES Decryption) key blob for secure memory region
        encryption with specified address range and cryptographic parameters.

        :param start_addr: Start address of the encrypted memory region.
        :param end_addr: End address of the encrypted memory region.
        :param key: AES encryption key (16 bytes); None to generate random key.
        :param counter_iv: Counter initialization vector for AES (16 bytes); None to generate random.
        :param key_flags: Key configuration flags using KEY_FLAG_xxx constants; default: VLD|ADE.
        :param zero_fill: Zero fill value for testing purposes; None to use random (recommended).
        :param crc: CRC fill value for testing purposes; None to use random (recommended).
        :raises SPSDKError: When start address is not properly aligned.
        :raises SPSDKError: When key or counter_iv have invalid length.
        :raises SPSDKError: When start/end addresses are invalid or out of range.
        :raises SPSDKError: When key_flags value exceeds allowed mask.
        """
        if key is None:
            key = random_bytes(self.KEY_SIZE)
        if counter_iv is None:
            counter_iv = random_bytes(self.CTR_SIZE)
        if (len(key) != self.KEY_SIZE) and (len(counter_iv) != self.CTR_SIZE):
            raise SPSDKError("Invalid key")
        if start_addr < 0 or start_addr > end_addr or end_addr > 0xFFFFFFFF:
            raise SPSDKError("Invalid start/end address")
        if key_flags & ~self._KEY_FLAG_MASK != 0:
            raise SPSDKError(f"key_flags exceeds mask {hex(self._KEY_FLAG_MASK)}")
        if (start_addr & self._START_ADDR_MASK) != 0:
            raise SPSDKError(
                f"Start address must be aligned to {hex(self._START_ADDR_MASK + 1)} boundary"
            )
        # if (end_addr & self._END_ADDR_MASK) != self._END_ADDR_MASK:
        #     raise SPSDKError(f"End address must be aligned to {hex(self._END_ADDR_MASK)} boundary")
        self.key = key
        self.ctr_init_vector = counter_iv
        self.start_addr = start_addr
        self.end_addr = end_addr
        self.key_flags = key_flags
        self.zero_fill = zero_fill
        self.crc_fill = crc

    def __str__(self) -> str:
        """Get string representation of the OTFAD region.

        Provides formatted information about the OTFAD region including encryption key,
        counter initialization vector, and memory address range.

        :return: Formatted string containing key, counter IV, start address, and end address.
        """
        msg = ""
        msg += f"Key:        {self.key.hex()}\n"
        msg += f"Counter IV: {self.ctr_init_vector.hex()}\n"
        msg += f"Start Addr: {hex(self.start_addr)}\n"
        msg += f"End Addr:   {hex(self.end_addr)}\n"
        return msg

    def plain_data(self) -> bytes:
        """Serialize OTFAD key blob data into binary format.

        The method creates a 64-byte binary representation of the OTFAD key blob containing
        the encryption key, counter initialization vector, address range, flags, and padding.

        :return: 64-byte binary data representing the serialized key blob.
        :raises SPSDKError: Invalid zero fill parameter length (must be 4 bytes).
        :raises SPSDKError: Invalid CRC fill parameter length (must be 4 bytes).
        :raises SPSDKError: Invalid binary data length (must be 64 bytes).
        """
        result = bytes()
        result += self.key
        result += self.ctr_init_vector
        result += pack("<I", self.start_addr)
        if self.end_addr or self.key_flags:
            end_addr_with_flags = (
                ((self.end_addr - 1) & ~self._KEY_FLAG_MASK) | self.key_flags | self._END_ADDR_MASK
            )
        else:
            end_addr_with_flags = 0
        result += pack("<I", end_addr_with_flags)
        header_crc = (
            from_crc_algorithm(CrcAlg.CRC32_MPEG)
            .calculate(result)
            .to_bytes(4, Endianness.LITTLE.value)
        )
        # zero fill
        if self.zero_fill:
            if len(self.zero_fill) != 4:
                raise SPSDKError("Invalid value")
            result += self.zero_fill
        else:
            result += random_bytes(4)
        # CRC is not used, use random value
        if self.crc_fill:
            if len(self.crc_fill) != 4:
                raise SPSDKError("Invalid value crc")
            result += self.crc_fill
        else:
            result += header_crc
        result += bytes([0] * 8)  # expanded_wrap_data
        result += bytes([0] * 16)  # unused filler
        if len(result) != 64:
            raise SPSDKError("Invalid length binary data")
        return result

    # pylint: disable=invalid-name
    def export(
        self,
        kek: Union[bytes, str],
        iv: bytes = bytes([0xA6] * 8),
        byte_swap_cnt: int = 0,
    ) -> bytes:
        """Export OTFAD key blob with AES key wrapping.

        Creates an encrypted key blob using AES key wrap algorithm with optional
        byte swapping for OTFAD (On-The-Fly AES Decryption) configuration.

        :param kek: Key encryption key as bytes or hex string; must be 16 bytes long
        :param iv: Counter initialization vector; must be 8 bytes; defaults to 0xA6 pattern
        :param byte_swap_cnt: Number of bytes to reverse in encrypted keyblob; 0 disables reversing
        :return: Exported key blob aligned to 64 bytes with zero padding
        :raises SPSDKError: If kek length is not 16 bytes
        :raises SPSDKError: If iv length is not 8 bytes
        :raises SPSDKError: If plaintext data length is insufficient for encryption
        """
        if isinstance(kek, str):
            kek = bytes.fromhex(kek)
        if len(kek) != 16:
            raise SPSDKError("Invalid length of kek")
        if len(iv) != self._EXPORT_CTR_IV_SIZE:
            raise SPSDKError("Invalid length of initialization vector")
        n = self._EXPORT_NBLOCKS_5
        plaintext = self.plain_data()  # input data to be encrypted
        if len(plaintext) < n * 8:
            raise SPSDKError("Invalid length of data to be encrypted")

        blobs = bytes()
        wrap = aes_key_wrap(kek, plaintext[:40])
        if byte_swap_cnt > 0:
            for i in range(0, len(wrap), byte_swap_cnt):
                blobs += wrap[i : i + byte_swap_cnt][::-1]
        else:
            blobs += wrap

        return align_block(
            blobs, self._EXPORT_KEY_BLOB_SIZE, padding=0
        )  # align to 64 bytes (0 padding)

    def _get_ctr_nonce(self) -> bytes:
        """Get the counter initial value for image encryption.

        Constructs a 16-byte counter nonce using the CTR initialization vector according to OTFAD
        specification. The nonce format includes the original CTR values, their XOR, and space
        for system address bits.

        :raises SPSDKError: If length of counter initialization vector is not 8 bytes.
        :return: 16-byte counter nonce for AES-CTR encryption.
        """
        #  CTRn_x[127-0] = {CTR_W0_x[C0...C3],    // 32 bits of pre-programmed CTR
        #  CTR_W1_x[C4...C7],                     // another 32 bits of CTR
        #  CTR_W0_x[C0...C3] ^ CTR_W1_x[C4...C7], // exclusive-OR of CTR values
        #  systemAddress[31-4], 0000b             // 0-modulo-16 system address */

        if len(self.ctr_init_vector) != 8:
            raise SPSDKError("Invalid length of counter init")

        result = bytearray(16)
        result[:4] = self.ctr_init_vector[:4]
        result[4:8] = self.ctr_init_vector[4:]
        for i in range(0, 4):
            result[8 + i] = self.ctr_init_vector[0 + i] ^ self.ctr_init_vector[4 + i]

        # result[15:12] = start_addr as a counter; nonce has these bytes zero and value passes as counter init value

        return bytes(result)

    def contains_addr(self, addr: int) -> bool:
        """Check if the key blob contains the specified address.

        :param addr: Memory address to be tested for containment within the key blob range.
        :return: True if the address is within the key blob's address range, False otherwise.
        """
        return self.start_addr <= addr <= self.end_addr

    def matches_range(self, image_start: int, image_end: int) -> bool:
        """Check if key blob matches the address range of the image to be encrypted.

        The method verifies that both the start and end addresses of the image
        fall within the address range covered by this key blob.

        :param image_start: Start address of the image to be encrypted.
        :param image_end: End address of the image to be encrypted.
        :return: True if the key blob covers the entire image address range, False otherwise.
        """
        return self.contains_addr(image_start) and self.contains_addr(image_end)

    def encrypt_image(
        self,
        base_address: int,
        data: bytes,
        byte_swap: bool,
        counter_value: Optional[int] = None,
    ) -> bytes:
        """Encrypt image data using AES-CTR encryption with OTFAD key blob.

        The method encrypts the provided data using AES-CTR mode with the key blob's
        encryption key. It supports byte swapping for different flash device organizations
        and validates address alignment and ranges.

        :param base_address: Base address of data in target memory, must be 16-byte aligned.
        :param data: Data to be encrypted (e.g. plain image data).
        :param byte_swap: Whether to swap bytes for flash device compatibility.
        :param counter_value: Optional counter value for encryption, defaults to start address.
        :return: Encrypted data with same length as input.
        :raises SPSDKError: If base address is not 16-byte aligned or encryption fails.
        """
        if base_address % 16 != 0:
            raise SPSDKError("Invalid start address")  # Start address has to be 16 byte aligned
        data = align_block(data, self._ENCRYPTION_BLOCK_SIZE)  # align data length
        data_len = len(data)

        # check start and end addresses
        # Support dual image boot, do not raise exception
        if not self.matches_range(base_address, base_address + data_len - 1):
            logger.warning(
                f"Image address range is not within key blob: "
                f"{hex(self.start_addr)}-{hex(self.end_addr)}."
                " Ignore this if flash remap feature is used"
            )
        result = bytes()

        if not counter_value:
            counter_value = self.start_addr

        counter = Counter(
            self._get_ctr_nonce(), ctr_value=counter_value, ctr_byteorder_encoding=Endianness.BIG
        )

        for index in range(0, data_len, 16):
            # prepare data in byte order
            if byte_swap:
                # swap 8 bytes + swap 8 bytes
                data_2_encr = (
                    data[-data_len + index + 7 : -data_len + index - 1 : -1]
                    + data[-data_len + index + 15 : -data_len + index + 7 : -1]
                )
            else:
                data_2_encr = data[index : index + 16]
            # encrypt
            encr_data = aes_ctr_encrypt(self.key, data_2_encr, counter.value)
            # fix byte order in result
            if byte_swap:
                result += encr_data[-9:-17:-1] + encr_data[-1:-9:-1]  # swap 8 bytes + swap 8 bytes
            else:
                result += encr_data
            # update counter for encryption
            counter.increment(16)

        if len(result) != data_len:
            raise SPSDKError("Invalid length of encrypted data")
        return bytes(result)

    @property
    def is_encrypted(self) -> bool:
        """Check if the OTFAD region requires encryption.

        This method determines whether encryption is required by checking if both
        the ADE (Address Decryption Enable) and VLD (Valid) flags are set in the
        key flags.

        :return: True if blob is encrypted, False otherwise.
        """
        return (bool)(
            (self.key_flags & (self.KEY_FLAG_ADE | self.KEY_FLAG_VLD))
            == (self.KEY_FLAG_ADE | self.KEY_FLAG_VLD)
        )


class Otfad(FeatureBaseClass):
    """OTFAD encryption and decryption module for NXP microcontrollers.

    This class provides On-the-Fly AES Decryption functionality for NXP MCU parts,
    managing encryption keys, key blobs, and binary image encryption. It handles
    OTFAD table generation, key scrambling, and provides a complete solution for
    secure boot and runtime decryption scenarios.

    :cvar FEATURE: Database feature identifier for OTFAD functionality.
    :cvar OTFAD_DATA_UNIT: Standard OTFAD data unit size (1024 bytes).
    """

    FEATURE = DatabaseManager.OTFAD

    OTFAD_DATA_UNIT = 0x400

    def __init__(
        self,
        family: FamilyRevision,
        kek: Union[bytes, str],
        table_address: int = 0,
        key_blobs: Optional[list[KeyBlob]] = None,
        key_scramble_mask: Optional[int] = None,
        key_scramble_align: Optional[int] = None,
        binaries: Optional[BinaryImage] = None,
        data_alignment: int = 512,
        otfad_table_name: str = "OTFAD_Table",
        otfad_all_name: str = "otfad_whole_image",
        generate_readme: bool = True,
        index: Optional[int] = None,
    ) -> None:
        """Initialize OTFAD (On-The-Fly AES Decryption) configuration.

        Sets up OTFAD encryption parameters, key blobs, and binary image handling for secure
        boot applications. Automatically fills minimum required key blobs if not provided.

        :param family: Target device family and revision information.
        :param kek: Key Encryption Key as bytes or hex string for OTFAD table encryption.
        :param table_address: Absolute memory address where OTFAD table will be located.
        :param key_blobs: List of KeyBlob objects for encryption regions, defaults to None.
        :param key_scramble_mask: Mask value for key scrambling algorithm (requires
            key_scramble_align).
        :param key_scramble_align: Alignment value for key scrambling algorithm (requires
            key_scramble_mask).
        :param binaries: Binary image to be encrypted, defaults to None.
        :param data_alignment: Byte alignment requirement for binary image data.
        :param otfad_table_name: Output filename for OTFAD table.
        :param otfad_all_name: Output filename for complete OTFAD image.
        :param generate_readme: Whether to generate documentation readme file.
        :param index: OTFAD peripheral index for fuse configuration, defaults to None.
        :raises SPSDKValueError: When family is unsupported, key scrambling parameters are
            incomplete, or database configuration is invalid.
        """
        self._key_blobs: list[KeyBlob] = []
        self.data_alignment = data_alignment
        self.otfad_table_name = otfad_table_name
        self.otfad_all_name = otfad_all_name
        self.generate_readme = generate_readme
        self.index = index

        if (key_scramble_align is None and key_scramble_mask) or (
            key_scramble_align and key_scramble_mask is None
        ):
            raise SPSDKValueError("Key Scrambling is not fully defined")

        self.family = family
        self.db = get_db(family)
        self.kek = bytes.fromhex(kek) if isinstance(kek, str) else kek
        self.key_scramble_mask = key_scramble_mask
        self.key_scramble_align = key_scramble_align
        self.table_address = table_address

        self.reversed_scramble_key = self.db.get_bool(
            DatabaseManager.OTFAD, "reversed_scramble_key", False
        )
        self.blobs_min_cnt = self.db.get_int(self.FEATURE, "key_blob_min_cnt")
        self.blobs_max_cnt = self.db.get_int(self.FEATURE, "key_blob_max_cnt")
        self.byte_swap = self.db.get_bool(self.FEATURE, "byte_swap")
        self.key_blob_rec_size = self.db.get_int(self.FEATURE, "key_blob_rec_size")
        self.keyblob_byte_swap_cnt = self.db.get_int(self.FEATURE, "keyblob_byte_swap_cnt")
        if self.keyblob_byte_swap_cnt not in [0, 2, 4, 8, 16]:
            raise SPSDKValueError(
                f"Invalid value of keyblob_byte_swap_cnt: {self.keyblob_byte_swap_cnt}"
            )
        self.binaries = binaries

        if key_blobs:
            for key_blob in key_blobs:
                self.add_key_blob(key_blob)

        # Just fill up the minimum count of key blobs
        while len(self._key_blobs) < self.blobs_min_cnt:
            self.add_key_blob(
                KeyBlob(
                    start_addr=0,
                    end_addr=0,
                    key=bytes([0] * KeyBlob.KEY_SIZE),
                    counter_iv=bytes([0] * KeyBlob.CTR_SIZE),
                    key_flags=0,
                    zero_fill=bytes([0] * 4),
                )
            )

    def __getitem__(self, index: int) -> KeyBlob:
        """Get key blob at specified index.

        :param index: Index of the key blob to retrieve.
        :return: Key blob at the specified index.
        """
        return self._key_blobs[index]

    def __setitem__(self, index: int, value: KeyBlob) -> None:
        """Set a key blob at the specified index.

        Replaces the existing key blob at the given index with a new key blob value.

        :param index: Index position where to set the key blob.
        :param value: Key blob to be set at the specified index.
        :raises IndexError: If the index is out of range.
        """
        self._key_blobs.remove(self._key_blobs[index])
        self._key_blobs.insert(index, value)

    def __len__(self) -> int:
        """Get the count of keyblobs in the OTFAD configuration.

        :return: Number of keyblobs currently stored.
        """
        return len(self._key_blobs)

    def add_key_blob(self, key_blob: KeyBlob) -> None:
        """Add key blob for specified address range.

        :param key_blob: Key blob object to be added to the collection.
        :raises SPSDKError: If the key blob is invalid or cannot be added.
        """
        self._key_blobs.append(key_blob)

    def encrypt_image(self, image: bytes, base_addr: int, byte_swap: bool) -> bytes:
        """Encrypt image with all available keyblobs.

        The method processes the image in data units and applies encryption using
        matching keyblobs based on address ranges. Only keyblobs that match the
        current address range and have encryption enabled are used.

        :param image: Plain image data to be encrypted.
        :param base_addr: Base address where the image will be located in target processor.
        :param byte_swap: Byte organization flag depending on flash device characteristics.
        :return: Encrypted image data.
        """
        encrypted_data = bytearray(image)
        addr = base_addr
        for block in split_data(image, self.OTFAD_DATA_UNIT):
            for key_blob in self._key_blobs:
                if key_blob.matches_range(addr, addr + len(block) - 1) and key_blob.is_encrypted:
                    logger.debug(
                        f"Encrypting {hex(addr)}:{hex(len(block) + addr - 1)}"
                        f" with keyblob: \n {str(key_blob)}"
                    )
                    encrypted_data[addr - base_addr : len(block) + addr - base_addr] = (
                        key_blob.encrypt_image(addr, block, byte_swap, counter_value=addr)
                    )
            addr += len(block)

        return bytes(encrypted_data)

    def get_key_blobs(self) -> bytes:
        """Get key blobs data as aligned binary block.

        The method concatenates all key blob plain data and aligns the result to 256 bytes
        for compatibility with elftosb tool and FLASH sector requirements.

        :return: Binary key blobs joined together and aligned to 256 bytes.
        """
        result = bytes()
        for key_blob in self._key_blobs:
            result += key_blob.plain_data()
        return align_block(
            result, 256
        )  # this is for compatibility with elftosb, probably need FLASH sector size

    def encrypt_key_blobs(
        self,
        kek: Union[bytes, str],
        key_scramble_mask: Optional[int] = None,
        key_scramble_align: Optional[int] = None,
        byte_swap_cnt: int = 0,
    ) -> bytes:
        """Encrypt key blobs with specified KEK (Key Encryption Key).

        The method encrypts all key blobs using the provided KEK. Optional scrambling
        can be applied to the KEK before encryption. The result is aligned to 256 bytes
        for flash sector compatibility.

        :param kek: Key Encryption Key as bytes or hex string to encrypt key blobs.
        :param key_scramble_mask: 32-bit scramble mask for KEK scrambling (optional).
        :param key_scramble_align: 8-bit scramble alignment for KEK scrambling (optional).
        :param byte_swap_cnt: Number of bytes to reverse in encrypted keyblob, 0 disables.
        :raises SPSDKValueError: Invalid scramble mask or align value.
        :return: Encrypted binary key blobs joined together and aligned to 256 bytes.
        """
        if isinstance(kek, str):
            kek = bytes.fromhex(kek)
        scramble_enabled = key_scramble_mask is not None and key_scramble_align is not None
        if scramble_enabled:
            assert isinstance(key_scramble_mask, int) and isinstance(key_scramble_align, int)
            if key_scramble_mask >= 1 << 32:
                raise SPSDKValueError("OTFAD Key scramble mask has invalid length")
            if key_scramble_align >= 1 << 8:
                raise SPSDKValueError("OTFAD Key scramble align has invalid length")

            logger.debug("The scrambling of keys is enabled.")

            if self.reversed_scramble_key:
                key_scramble_mask = reverse_bits(key_scramble_mask, 32)

            key_scramble_mask_bytes = key_scramble_mask.to_bytes(
                4, byteorder=Endianness.LITTLE.value
            )
            logger.debug(f"The inverted scramble key is: {key_scramble_mask_bytes.hex()}")
        result = bytes()
        scrambled = bytes()
        for i, key_blob in enumerate(self._key_blobs):
            if scramble_enabled:
                assert isinstance(key_scramble_mask, int) and isinstance(key_scramble_align, int)
                scrambled = bytearray(kek)
                long_ix = (key_scramble_align >> (i * 2)) & 0x03
                for j in range(4):
                    scrambled[(long_ix * 4) + j] ^= key_scramble_mask_bytes[j]

            logger.debug(
                f"Used KEK for keyblob{i} encryption is: {scrambled.hex() if scramble_enabled else kek.hex()}"
            )

            result += key_blob.export(
                scrambled if scramble_enabled else kek, byte_swap_cnt=byte_swap_cnt
            )
        return align_block(
            result, 256
        )  # this is for compatibility with elftosb, probably need FLASH sector size

    def __repr__(self) -> str:
        """Get string representation of OTFAD object.

        :return: String representation showing the target family for this OTFAD instance.
        """
        return f"Otfad object for {self.family}"

    def __str__(self) -> str:
        """Get string representation of the OTFAD key-blob collection.

        Provides a formatted text representation showing all key-blobs in the collection
        with their index numbers and detailed information.

        :return: Formatted string containing information about all key-blobs.
        """
        msg = "Key-Blob\n"
        for index, key_blob in enumerate(self._key_blobs):
            msg += f"Key-Blob {str(index)}:\n"
            msg += str(key_blob)
        return msg

    @property
    def scramble_enabled(self) -> bool:
        """Property indicating if the scrambling is enabled.

        :return: True if both key_scramble_mask and key_scramble_align are set, False otherwise.
        """
        return self.key_scramble_mask is not None and self.key_scramble_align is not None

    @staticmethod
    def get_blhost_script_otp_keys(
        family: FamilyRevision, otp_master_key: bytes, otfad_kek_seed: bytes
    ) -> str:
        """Create BLHOST script to load fuses needed to run OTFAD with OTP fuses.

        This method generates a script that can be used with BLHOST tool to program
        the necessary fuse values for OTFAD (On-The-Fly AES Decryption) operation
        using OTP (One-Time Programmable) keys.

        :param family: Device family and revision information.
        :param otp_master_key: OTP Master Key used for OTFAD encryption.
        :param otfad_kek_seed: OTFAD Key Encryption Key seed value.
        :return: BLHOST script content as string that loads the keys into fuses.
        """
        fuses_script = FuseScript(family, DatabaseManager.OTFAD)

        @dataclass
        class OTP:
            """OTFAD OTP data container.

            This class stores One-Time Programmable (OTP) values used in OTFAD
            (On-The-Fly AES Decryption) operations, including the master key
            and KEK seed values.
            """

            otp_master_key: bytes
            otfad_kek_seed: bytes

        otp = OTP(otp_master_key, otfad_kek_seed)

        return fuses_script.generate_script(otp)

    def get_blhost_script_otp_kek(self, index: int = 1) -> str:
        """Create BLHOST script to load fuses needed to run OTFAD with OTP fuses just for OTFAD key.

        :param index: Index of OTFAD peripheral [1, 2, ..., n].
        :return: BLHOST script that loads the keys into fuses.
        """
        if not self.db.get_bool(self.FEATURE, "has_kek_fuses", default=False):
            logger.debug(f"The {self.family} has no OTFAD KEK fuses")
            return ""

        fuses_script = FuseScript(self.family, self.FEATURE, index)
        return fuses_script.generate_script(self)

    def export_image(
        self,
        plain_data: bool = False,
        swap_bytes: bool = False,
        join_sub_images: bool = True,
        table_address: int = 0,
    ) -> Optional[BinaryImage]:
        """Export OTFAD key blob as binary image representation.

        The method processes binary data by aligning blocks to encryption size, optionally
        encrypting the data based on OTFAD table addresses, and joining sub-images if requested.

        :param plain_data: Binary representation in plain data format, defaults to False
        :param swap_bytes: For some platforms byte swapping is needed in encrypted format, defaults to False
        :param join_sub_images: If True, all binary sub-images are joined into one, defaults to True
        :param table_address: Absolute address of OTFAD table
        :return: OTFAD key blob data in BinaryImage format, or None if no binaries available
        """
        if self.binaries is None:
            return None
        binaries: BinaryImage = deepcopy(self.binaries)
        for binary in binaries.sub_images:
            if binary.binary:
                binary.binary = align_block(binary.binary, KeyBlob._ENCRYPTION_BLOCK_SIZE)
            for segment in binary.sub_images:
                if segment.binary:
                    segment.binary = align_block(segment.binary, KeyBlob._ENCRYPTION_BLOCK_SIZE)

        binaries.validate()

        if not plain_data:
            for binary in binaries.sub_images:
                if binary.binary:
                    binary.binary = self.encrypt_image(
                        binary.binary,
                        table_address + binary.absolute_address,
                        swap_bytes,
                    )
                for segment in binary.sub_images:
                    if segment.binary:
                        segment.binary = self.encrypt_image(
                            segment.binary,
                            segment.absolute_address + table_address,
                            swap_bytes,
                        )

        if join_sub_images:
            binaries.join_images()
            binaries.validate()

        return binaries

    def binary_image(
        self,
        plain_data: bool = False,
        data_alignment: int = 16,
        otfad_table_name: str = "OTFAD_Table",
    ) -> BinaryImage:
        """Get the OTFAD Binary Image representation.

        Creates a binary image containing the OTFAD table and associated data with proper
        alignment and encryption settings.

        :param plain_data: Binary representation in plain format, defaults to False
        :param data_alignment: Alignment of data part key blobs
        :param otfad_table_name: Name of the output file that contains OTFAD table
        :return: OTFAD in BinaryImage format
        """
        otfad = BinaryImage("OTFAD", offset=self.table_address)
        # Add mandatory OTFAD table
        otfad_table = (
            self.get_key_blobs()
            if plain_data
            else self.encrypt_key_blobs(
                self.kek,
                self.key_scramble_mask,
                self.key_scramble_align,
                self.keyblob_byte_swap_cnt,
            )
        )
        otfad.add_image(
            BinaryImage(
                otfad_table_name,
                size=self.key_blob_rec_size * self.blobs_max_cnt,
                offset=0,
                description=f"OTFAD description table for {self.family}",
                binary=otfad_table,
                alignment=256,
            )
        )
        binaries = self.export_image(table_address=self.table_address)

        if binaries:
            binaries.alignment = data_alignment
            binaries.validate()
            otfad.add_image(binaries)
        return otfad

    def export(self) -> bytes:
        """Export object into bytes array.

        :return: Exported object as bytes.
        :raises NotImplementedError: If not implemented in the specific subclass.
        """
        raise NotImplementedError()

    @classmethod
    def parse(cls, data: bytes) -> Self:
        """Parse OTFAD keyblob from bytes array.

        This is an abstract method that must be implemented by specific OTFAD subclasses
        to handle parsing of their respective keyblob formats.

        :param data: OTFAD keyblob in bytes format.
        :return: Parsed OTFAD object instance.
        :raises NotImplementedError: If not implemented in the specific subclass.
        """
        raise NotImplementedError()

    @classmethod
    def get_validation_schemas(cls, family: FamilyRevision) -> list[dict[str, Any]]:
        """Get list of validation schemas for OTFAD configuration.

        This method retrieves and configures validation schemas specific to the given family,
        including family-specific schema updates, memory address configurations from FlexSPI
        base addresses, and any additional schemas defined in the database.

        :param family: Family revision for which the validation schemas should be generated.
        :return: List of validation schema dictionaries including family, output, and OTFAD schemas.
        """
        database = get_db(family)
        schemas = get_schema_file(cls.FEATURE)
        sch_family = get_schema_file("general")["family"]
        update_validation_schema_family(
            sch_family["properties"], Otfad.get_supported_families(), family
        )
        sch_family["main_title"] = f"On-The-Fly AES decryption Configuration for {family}."
        sch_family["note"] = database.get_str(cls.FEATURE, "additional_template_text", default="")
        # Update address in the schema template
        try:
            flexspi_base = database.device.info.memory_map.get_memory(
                block_name="flexspi1_ns"
            ).base_address
            schemas["otfad"]["properties"]["otfad_table_address"]["template_value"] = hex(
                flexspi_base
            )
            schemas["otfad"]["properties"]["data_blobs"]["items"]["properties"]["address"][
                "template_value"
            ] = hex(flexspi_base + 0x1000)
            schemas["otfad"]["properties"]["key_blobs"]["items"]["properties"]["start_address"][
                "template_value"
            ] = hex(flexspi_base + 0x1000)
            schemas["otfad"]["properties"]["key_blobs"]["items"]["properties"]["end_address"][
                "template_value"
            ] = hex(flexspi_base + 0x10000)
        except (SPSDKError, KeyError):
            pass

        ret = [sch_family, schemas["otfad_output"], schemas["otfad"]]
        additional_schemes = database.get_list(cls.FEATURE, "additional_template", default=[])
        ret.extend([schemas[x] for x in additional_schemes])
        return ret

    def get_config(self, data_path: str = "./") -> Config:
        """Create configuration of the Feature.

        :param data_path: Path to store the data files of configuration.
        :raises NotImplementedError: Method must be implemented by subclass.
        :return: Configuration dictionary.
        """
        raise NotImplementedError

    @classmethod
    def load_from_config(cls, config: Config) -> Self:
        """Create OTFAD image object from configuration.

        Converts the configuration dictionary containing OTFAD settings into a fully
        initialized OTFAD image object with key blobs and optional data blobs.

        :param config: Configuration dictionary containing OTFAD settings including
                       key blobs, KEK, addresses, and optional data blobs.
        :return: Initialized OTFAD object with configured key blobs and settings.
        """
        otfad_config = config.get_list_of_configs("key_blobs")
        family = FamilyRevision.load_from_config(config)
        database = get_db(family)
        kek = config.load_symmetric_key("kek", expected_size=16)
        logger.debug(f"Loaded KEK: {kek.hex()}")
        table_address = config.get_int("otfad_table_address")
        start_address = min([addr.get_int("start_address") for addr in otfad_config])

        key_scramble_mask = None
        key_scramble_align = None
        if database.get_bool(cls.FEATURE, "supports_key_scrambling", default=False):
            if "key_scramble" in config.keys():
                key_scramble = config["key_scramble"]
                key_scramble_mask = value_to_int(key_scramble["key_scramble_mask"])
                key_scramble_align = value_to_int(key_scramble["key_scramble_align"])

        binaries = None
        if "data_blobs" in config:
            data_blobs = config.get_list_of_configs("data_blobs")
            # pylint: disable-next=nested-min-max
            start_address = min(
                min([addr.get_int("address") for addr in data_blobs]), start_address
            )
            binaries = BinaryImage(
                filepath_from_config(
                    config,
                    "encrypted_name",
                    "encrypted_blobs",
                    config["output_folder"],
                ),
                offset=start_address - table_address,
            )
            for data_blob in data_blobs:
                data = load_binary(data_blob.get_input_file_name("data"))
                address = data_blob.get_int("address")

                binary = BinaryImage(
                    os.path.basename(data_blob["data"]),
                    offset=address - table_address - binaries.offset,
                    binary=data,
                )
                binaries.add_image(binary)
        else:
            logger.warning("The OTFAD configuration has NOT any data blobs records!")

        output_folder = config.get_output_file_name("output_folder")
        otfad_table_name = filepath_from_config(
            config, "keyblob_name", "OTFAD_Table", output_folder
        )
        otfad_all = filepath_from_config(config, "output_name", "otfad_whole_image", output_folder)
        generate_readme = config.get("generate_readme", True)
        data_alignment = config.get_int("data_alignment", 512)
        try:
            index = config.get_int("index")
        except SPSDKError:
            index = None

        otfad = cls(
            family=family,
            kek=kek,
            table_address=table_address,
            key_scramble_align=key_scramble_align,
            key_scramble_mask=key_scramble_mask,
            binaries=binaries,
            data_alignment=data_alignment,
            otfad_table_name=otfad_table_name,
            otfad_all_name=otfad_all,
            generate_readme=generate_readme,
            index=index,
        )

        for i, key_blob_cfg in enumerate(otfad_config):
            aes_key = value_to_bytes(key_blob_cfg["aes_key"], byte_cnt=KeyBlob.KEY_SIZE)
            aes_ctr = value_to_bytes(key_blob_cfg["aes_ctr"], byte_cnt=KeyBlob.CTR_SIZE)
            start_addr = key_blob_cfg.get_int("start_address")
            end_addr = key_blob_cfg.get_int("end_address")
            aes_decryption_enable = key_blob_cfg.get("aes_decryption_enable", True)
            valid = key_blob_cfg.get("valid", True)
            read_only = key_blob_cfg.get("read_only", True)
            flags = 0
            if aes_decryption_enable:
                flags |= KeyBlob.KEY_FLAG_ADE
            if valid:
                flags |= KeyBlob.KEY_FLAG_VLD
            if read_only:
                flags |= KeyBlob.KEY_FLAG_READ_ONLY

            otfad[i] = KeyBlob(
                start_addr=start_addr,
                end_addr=end_addr,
                key=aes_key,
                counter_iv=aes_ctr,
                key_flags=flags,
                zero_fill=bytes([0] * 4),
            )

        return otfad

    def post_export(self, output_path: str) -> list[str]:
        """Perform post export steps like saving the script files.

        This method generates and saves various OTFAD-related files including binary images,
        readme documentation, BD file examples for SB2.1, and BLHOST scripts for OTP KEK
        configuration. It processes the binary image structure and creates separate files
        for OTFAD table and key blobs.

        :param output_path: Directory path where generated files will be saved.
        :return: List of file paths that were successfully generated and saved.
        """
        generated_files = []

        binary_image = self.binary_image(
            data_alignment=self.data_alignment, otfad_table_name=self.otfad_table_name
        )
        sb21_supported = self.db.get_bool(DatabaseManager.OTFAD, "sb_21_supported", default=False)
        logger.info(f" The OTFAD image structure:\n{binary_image.draw()}")
        if self.otfad_all_name != "":
            write_file(binary_image.export(), self.otfad_all_name, mode="wb")
            logger.info(f"Created OTFAD Image:\n{self.otfad_all_name}")
        else:
            logger.info("Skipping export of OTFAD image")

        memory_map = (
            "In folder is stored two kind of files:\n"
            "  -  Binary file that contains whole image data including "
            "OTFAD table and key blobs data 'otfad_whole_image.bin'.\n"
        )
        if sb21_supported:
            memory_map += "  -  Example of BD file to simplify creating the SB2.1 file from the OTFAD source files.\n"
            bd_file_sources = "sources {"
            bd_file_section0 = "section (0) {"

        memory_map += (
            "  -  Set of separated binary files, one with OTFAD table, and one for each used key blob.\n"
            f"\nOTFAD memory map:\n{binary_image.draw(no_color=True)}"
        )

        for i, image in enumerate(binary_image.sub_images):
            if image.name != "":
                write_file(image.export(), image.name, mode="wb")
                generated_files.append(image.name)
                logger.info(f"Created OTFAD Image:\n{image.name}")
                memory_map += f"\n{image.name}:\n{str(image)}"
            else:
                logger.info(
                    f"Skipping export of {str(image)}, value is blank in the configuration file"
                )
            if sb21_supported:
                bd_file_sources += f'\n    image{i} = "{image.name}";'
                bd_file_section0 += f"\n    // Load Image: {image.name}"
                bd_file_section0 += f"\n    erase {hex(image.absolute_address)}..{hex(image.absolute_address+len(image))};"  # pylint: disable=line-too-long
                bd_file_section0 += f"\n    load image{i} > {hex(image.absolute_address)}"

        readme_file = os.path.join(output_path, "readme.txt")

        if self.generate_readme:
            write_file(memory_map, readme_file)
            generated_files.append(readme_file)
            logger.info(f"Created OTFAD readme file:\n{readme_file}")
        else:
            logger.info("Skipping generation of OTFAD readme file")

        if sb21_supported:
            bd_file_name = os.path.join(output_path, "sb21_otfad_example.bd")
            bd_file_sources += "\n}\n"
            bd_file_section0 += "\n}\n"
            bd_file = (
                "options {\n"
                "    flags = 0x8; // for sb2.1 use only 0x8 encrypted + signed\n"
                "    buildNumber = 0x1;\n"
                '    productVersion = "1.00.00";\n'
                '    componentVersion = "1.00.00";\n'
                '    secureBinaryVersion = "2.1";\n'
                "}\n"
            )
            bd_file += bd_file_sources
            bd_file += bd_file_section0

            write_file(bd_file, bd_file_name)
            generated_files.append(bd_file_name)
            logger.info(f"Created OTFAD BD file example:\n{bd_file_name}")

        if self.db.get_bool(DatabaseManager.OTFAD, "has_kek_fuses", default=False) and self.index:
            blhost_script = None
            blhost_script = self.get_blhost_script_otp_kek(self.index)
            if blhost_script:
                blhost_script_filename = os.path.join(
                    output_path, f"otfad{self.index}_{self.family.name}.bcf"
                )
                write_file(blhost_script, blhost_script_filename)
                generated_files.append(blhost_script_filename)
                logger.info(f"Created OTFAD BLHOST load fuses script:\n{blhost_script_filename}")

        return generated_files
